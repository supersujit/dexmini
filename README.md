# DexMini Application for comparing robot scans with human scans

## Introduction
This application is a simple webapp created as a solution to the assignment. The application is designed to accept 
the robot scan data of a warehouse and let user compare it with the human scan data. It lets user view the result of
comparison in a tabular format or export the result in a CSV format.

## Technologies Overview
- Ruby on Rails: The application is built using Ruby on Rails framework.
- html.erb: templates for rendering the views.
- ActiveStorage: For storing the uploaded files (robot scan as well as manual scans).
- Postgresql: For storing the data.
- RSpec: For writing the tests.
- Sidekiq: For processing the background jobs.
- TailwindCSS: For styling the views.

## Features
1. An API end point is provided to upload the robot scan data in json format.
2. A paginated list of uploaded robot scans to select of comparison.
3. A form to upload the manual scan data for comparison.
4. A paginated list of comparison results for each locations.
5. A button to export the comparison results in CSV format.

## Demo


https://github.com/supersujit/dexmini/assets/10810996/81395049-5310-46bc-bfd1-cf38602fcb4d



## Setup
Please follow below steps to setup the application (Please see troubleshooting section for any issues):
1. `bundle install` - To install the dependencies.
2. `rails db:create db:migrate` - To create the database and run the migrations.
3. `redis-server` - To start the redis server. (This is needed by sidekiq for background jobs)
4. `./bin/dev` - To start the server. (Prefer is over 'rails s' as it also compiles the assets and starts sidekiq server)

## Running the tests
`bundle exec rspec` - To run the tests.

## Highlights and best practices
1. ActiveStorage is used to store the uploaded files. The filetype is restricted to json for robot scan and csv for manual scan.
2. Users or robots are not made to wait for processing the uploaded files. Sidekiq is used to process the background jobs.
3. Service objects are used to encapsulate the business logic and follow Single Responsibility Principle.
4. Tests are written in RSpec by mocking the calls.
5. Tried to keep models and controllers as thin as possible.
6. The code follows DRY principle so that no code is repeated.
7. The application is designed to be user friendly and responsive.

## Solution Approach
1. The solution has `location_scans` as the central entity which stores the scan data from robot as well as manual scans.
2. Populating the `location_scans` table is done through `RobotScansProcessor` and `ManualScansProcessor` service objects.
3. The actual comparison is used by using SQL query. This approach helps keeping the comparison logic efficient by using
DB indexes. This ensures no performance load on the application server for huge data. You can find this code in 
`ComparisonReportGenerator` service object.
4. Single table inheritance is used to store the different types of scans through `RobotScan` and `ManualScan` models.
5. Sidekiq jobs are used to process the robot scans (using `ProcessScannedFileJob`) and create the comparison report
(using `GenerateComparisonReportJob`).

## Next Steps
1. After uploading the manual scan data, the comparison report is generated in the background and user has to 'fetch report'
too see the results. This can be changed to show the results as soon as the report is generated by implementing a heartbeat
mechanism which keeps polling the server for the report status periodically if not ready.
2. The robot scan file processing can be improved by using a more efficient way to process the json data. Currently, the
json data is read line by line and processed. This can be improved by using a more efficient way to process the json data like 
**using a streaming parser**.
3. There is no authentication or authorization implemented. This can be added for security.
4. Currently the application only uses `:local` storage for ActiveStorage. Cloud storage can be configured for other environments.

## Troubleshooting
1. Problem starting redis-server:
    - Make sure redis is installed. If not, install it using `brew install redis`.
2. Problem starting sidekiq:
    - Make sure redis server is running.
    - If still facing issue, try starting sidekiq using `bundle exec sidekiq` command.
3. If you want more control over the logs and ease of debugging, you can start the servers separately:
    - `rails s` - To start the rails server.
    - `rails tailwindcss:watch` - To start the webpack server.
    - `bundle exec sidekiq` - To start the sidekiq server. 
4. Installing Postgresql:
    - If you are facing issues with Postgresql installation, you can install it using brew: `brew install postgresql` and 
    start the server using `brew services start postgresql`.
    - Alternatively you can use the docker image to run the Postgresql server.
      - Run the below command to start the Postgresql server using docker:
          ```
          docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres
          ```
      - Update the `config/database.yml` file to use the docker Postgresql server.
